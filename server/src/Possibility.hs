module Possibility where

import ArtificialIntelligence (Weight, evalState)
import Control.Monad.Free (hoistFree)
import Control.Monad.Trans.Writer (runWriter)
import Card (Card(..))
import Data.List (maximumBy)
import Data.Ord (comparing)
import GameCommand (resolveAll')
import GameState (PlayState)
import Model (Model(..))
import Player (WhichPlayer)
import Util (Gen, infiniteGens, split)
import Wheel (Wheel(..))

import qualified Replay.Active as Replay

import qualified DSL.Alpha as Alpha
import qualified DSL.Beta as Beta


chooseTimeline :: WhichPlayer -> Alpha.Program ()
chooseTimeline w = do
  -- infiniteGens are generated by taking the fst of a split
  -- taking the snd here ensures that we don't always look at the same timelines
  -- when we take multiple choices
  gen <- snd . split <$> Alpha.getGen
  initialModel <- Alpha.getModel
  let model = Alpha.modI initialModel (Alpha.modStack (\stack -> stack { wheel_0 = Nothing }))
  let gens = take 5 (infiniteGens gen) :: [Gen]
  let models = fmap (\g -> model { model_gen = g }) gens :: [Model]
  let states = fmap (\m -> fst . runWriter $ resolveAll' m Replay.null 0 rewrite) models :: [PlayState]
  let weights = fmap (evalState w) states :: [Weight]
  let (_, newGen) = maximumBy (comparing fst) (zip weights gens)
  Alpha.setGen newGen


-- This rewrite rule is here to avoid 5^n complexity, where n = depth of recursive timelines chosen.
-- Rewrite rule avoids recursive timeline choices.
rewrite :: Card -> Card
rewrite card = card { card_eff = \w -> hoistFree rule $ card_eff card w }
  where
    rule :: Beta.DSL a -> Beta.DSL a
    rule (Beta.ChooseTimeline _ n) = Beta.Null n
    rule dsl = dsl
